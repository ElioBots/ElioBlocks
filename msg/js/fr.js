/**
 * @author : Boutrois Romain & Morel Guillaume
 * @description : Version française de l'application
 */

// Version Française des blocs de condition
Blockly.Msg["LOGIC_BOOLEAN_TRUE"] = "vrai",
Blockly.Msg["LOGIC_BOOLEAN_FALSE"] = "faux",
Blockly.Msg["CONTROLS_IF_MSG_IF"] = "Si",
Blockly.Msg["CONTROLS_IF_MSG_THEN"] = "Alors",
Blockly.Msg["CONTROLS_IF_MSG_ELSE"] = "Sinon",
Blockly.Msg["LOGIC_OPERATION_AND"] = "et",
Blockly.Msg["LOGIC_OPERATION_OR"] = "ou",
Blockly.Msg["LOGIC_NEGATE_TITLE"] = "non",
Blockly.Msg["LOGIC_NULL"] = "est nul",
Blockly.Msg["LOGIC_TERNARY_CONDITION"] = "Vrai ou Faux ?",
Blockly.Msg["LOGIC_TERNARY_IF_TRUE"] = "Si c'est vrai, on fait =",
Blockly.Msg["LOGIC_TERNARY_IF_FALSE"] = "Si c'est faux, on fait =",
Blockly.Msg["CONTROLS_IF_IF_TITLE_IF"] = "Si",
Blockly.Msg["CONTROLS_IF_ELSEIF_TITLE_ELSEIF"] = "Sinon, Si",
Blockly.Msg["CONTROLS_IF_ELSE_TITLE_ELSE"] = "Sinon",
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_EQ"] = "est égal à",
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_NEQ"] = "n'est pas égal à",
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_LT"] = "est inférieur à",
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_LTE"] = "est inférieur ou égal à",
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_GT"] = "est suppérieur à",
Blockly.Msg["LOGIC_COMPARE_TOOLTIP_GTE"] = "est supérieur ou égal à",
Blockly.Msg["LOGIC_OPERATION_TOOLTIP_AND"] = "et",
Blockly.Msg["LOGIC_OPERATION_TOOLTIP_OR"] = "ou",
Blockly.Msg["CONTROLS_IF_MSG_ELSEIF"] = "Sinon, Si",
Blockly.Msg["CONTROLS_IF_MSG_THEN"] = "Alors faire :",
Blockly.Msg["CONTROLS_IF_MSG_ELSE"] = "Sinon",

// Version Française des blocs de boucle
Blockly.Msg["CONTROLS_REPEAT_TITLE"] = "Tant que",
Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"] = "Faire",
Blockly.Msg["CONTROLS_WHILEUNTIL_OPERATOR_WHILE"] = "Tant que",
Blockly.Msg["CONTROLS_WHILEUNTIL_OPERATOR_UNTIL"] = "Jusqu'à ce que",
Blockly.Msg["CONTROLS_FOR_TITLE"] = "Pour",
Blockly.Msg["CONTROLS_FOREACH_TITLE"] = "Pour chaque",
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK"] = "Stopper boucle",
Blockly.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE"] = "Continuer boucle"

// Vesion Française des blocs modules
Blockly.Msg["LEDS_PLACEMENT_TEXT"] = "à l'emplacement",
Blockly.Msg["LEDS_RGB_COLOUR_TEXT"] = "avec la couleur",
Blockly.Msg["LEDS_STATE_HIGH"] = "Allumer",
Blockly.Msg["LEDS_STATE_LOW"] = "Eteindre",
Blockly.Msg["ROBOT_MOVE_TEXT"] = "Déplacer le robot vers",
Blockly.Msg["ROBOT_SPEED_TEXT"] = "à vitesse",
Blockly.Msg["ROBOT_MOVE_FORWARD"] = "l'avant",
Blockly.Msg["ROBOT_MOVE_BACKWARD"] = "l'arrière",
Blockly.Msg["ROBOT_SPEED_SLOW"] = "lente",
Blockly.Msg["ROBOT_SPEED_MEDIUM"] = "moyenne",
Blockly.Msg["ROBOT_SPEED_FAST"] = "rapide",
Blockly.Msg["ROBOT_TURN_RIGHT"] = "la droite",
Blockly.Msg["ROBOT_TURN_TEXT"] = "Tourner le robot vers",
Blockly.Msg["ROBOT_TURN_LEFT"] = "la gauche",
Blockly.Msg["ROBOT_TURN_BACKWARD"] = "l'arrière",
Blockly.Msg["ROBOT_ROTA_TEXT"] = "Faire une rotation du robot de",
Blockly.Msg["ROBOT_STOP"] = "Arrêter le robot",
Blockly.Msg["TO_BE_OBSTACLES_OR_NOT_OBSTACLES"] = "Obstacle",
Blockly.Msg["ROBOT_SENSOR_FORWARD"] = "devant",
Blockly.Msg["ROBOT_SENSOR_BACKWARD"] = "derrière",
Blockly.Msg["ROBOT_SENSOR_RIGHT"] = "à droite",
Blockly.Msg["ROBOT_SENSOR_LEFT"] = "à gauche",
Blockly.Msg["TO_BE_LINE_OR_NOT_LINE"] = "Ligne ?",
Blockly.Msg["ROBOT_FOLLOW_LINE_TEXT"] = "Suivre la ligne pendant",
Blockly.Msg["ROBOT_FOLLOW_LINE_SECOUNDS_TEXT"] = "seconde(s)",
Blockly.Msg["ROBOT_FOLLOW_LINE_SPEED_TEXT"] = "à une vitesse"

// Version Française des blocs math
Blockly.Msg["MATH_ADDITION_SYMBOL"] = "+",
Blockly.Msg["MATH_SUBTRACTION_SYMBOL"] = "-",
Blockly.Msg["MATH_MULTIPLICATION_SYMBOL"] = "*",
Blockly.Msg["MATH_DIVISION_SYMBOL"] = "/",
Blockly.Msg["MATH_POWER_SYMBOL"] = "^",
Blockly.Msg["MATH_SINGLE_OP_ROOT"] = "√",
Blockly.Msg["MATH_SINGLE_OP_ABSOLUTE"] = "|abs|",
Blockly.Msg["MATH_TRIG_SIN"] = "sinus de",
Blockly.Msg["MATH_TRIG_CO"] = "cosinus de",
Blockly.Msg["MATH_TRIG_TAN"] = "tangente de",
Blockly.Msg["MATH_TRIG_ASIN"] = "archsinus de",
Blockly.Msg["MATH_TRIG_ACOS"] = "archcosinus de",
Blockly.Msg["MATH_TRIG_ATAN"] = "archtangente de",
Blockly.Msg["MATH_IS_EVEN"] = "est pair",
Blockly.Msg["MATH_IS_ODD"] = "est impair",
Blockly.Msg["MATH_IS_PRIME"] = "est un nombre premier",
Blockly.Msg["MATH_IS_WHOLE"] = "est un entier",
Blockly.Msg["MATH_IS_POSITIVE"] = "est positif",
Blockly.Msg["MATH_IS_NEGATIVE"] = "est negatif",
Blockly.Msg["MATH_IS_DIVISIBLE_BY"] = "est divisible par",
Blockly.Msg["MATH_ROUND_OPERATOR_ROUND"] = "arrondir le nombre",
Blockly.Msg["MATH_ROUND_OPERATOR_ROUNDUP"] = "arrondir au supérieur le nombre",
Blockly.Msg["MATH_ROUND_OPERATOR_ROUNDDOWN"] = "arrondir à l'inférieur le nombre",
Blockly.Msg["MATH_ONLIST_OPERATOR_TEXT"] = "Trouver",
Blockly.Msg["MATH_ONLIST_OPERATOR_SUM"] = "la somme",
Blockly.Msg["MATH_ONLIST_OPERATOR_MIN"] = "le minimum",
Blockly.Msg["MATH_ONLIST_OPERATOR_MAX"] = "le maximum",
Blockly.Msg["MATH_ONLIST_OPERATOR_AVERAGE"] = "la moyenne",
Blockly.Msg["MATH_ONLIST_OPERATOR_MEDIAN"] = "la médiane",
Blockly.Msg["MATH_ONLIST_OPERATOR_MODE"] = "les nombres fréquents",
Blockly.Msg["MATH_ONLIST_OPERATOR_STD_DEV"] = "l'écart type",
Blockly.Msg["MATH_ONLIST_OPERATOR_RANDOM"] = "les éléments aléatoires",
Blockly.Msg["MATH_MODULO_TITLE"] = "les éléments aléatoires",
Blockly.Msg["MATH_MODULO_SYMBOL"] = "%",
Blockly.Msg["MATH_MODULO_TITLE"] = "les éléments aléatoires",

// Version Française des blocs de déclaration des variables
Blockly.Msg["NEW_VARIABLE"] = "Créer une nouvelle variable"